# SFIA Project 2
### Amogh Naik

## Contents
* [Introduction](#Introduction)
* [My Journey through QA Academy](#Journey)
* [Planning](#Planning)
* [User Stories & Use Cases](#User)
* [Risk Analysis](#Risk)
* [Back end architecture](#Back)
* [Front end architecture](#Front)
* [Testing](#Testing)
* [CI Pipeline & Deployment](#Deployment)
* [User Guide to Launch Application](#Guide)
* [Project Changes & Conclusion](#Conclusion)
* [Acknowledgements](#Acknowedgements)

<a name="Introduction"></a>
## Introduction
Welcome to this brief guide where I will explain how I planned, created, tested and deployed a service-oriented web application as part of my second SFIA project at QA Academy.
### Project Aims
The aims of the project were as follows:
* To create a service-oriented web application using Python Flask. The application must consist of two services that generate a random item, one service that generates another item based on the two random items and a front-end service where users can view this item and which persists some data in an SQL database. There must be two different implementations of the project which can be switched without disrupting the user experience.
* To plan the project using a Kanban board, making note of user stories, use cases and potential risks. 
* To test the application using pytest and analyse test coverage.
* To deploy the application through a CI pipeline using Jenkins and Github. Each service must be run in a separate container by using Docker and an Ansible playbook must be used to provision the environment needed for the application to run. 
* To provide thorough documentation for all of the above, including a user guide for launching the application.
### My Solution
My solution was to create a web application that can generate a proverb based on a random number and letter. Users can generate proverbs once they have logged in and all proverbs generated by a user are then saved on a database so that they can be viewed at a later date.

<a name="Journey"></a>
## My Journey through QA Academy
In each week of learning at QA Academy, I gained new skills and used new tools which would help me construct the application:
* Week 1 - Project management, Documentation
* Week 2 - SQL databases, GCP
* Week 3 - Python coding and testing
* Week 4 - Jenkins, Flask
* Week 5 - Flask, Testing, Deployment
* Week 6 - Linux, Service-oriented applications
* Week 7 - Docker, Docker compose
* Week 8 - Docker swarm, Ansible

<a name="Planning"></a>
## Planning
I used Trello to plan my project. My justification for using Trello is that it is free, easy to use and clearly structured. My Trello board is shown below:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Trello_board.png)

<a name="User"></a>
## User Stories & Use Cases
For this project, I identified three user stories:
* As a teacher, I want to view proverbs so that I can teach children good lessons and morals.
* As a philosopher, I want to look at proverbs so that I can further my understanding of philosophy.
* As a writer, I want to view proverbs so that I can get inspiration for my novel.

Two typical use cases which show all of the features of the application are:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/usecases.jpg)

<a name="Risk"></a>
## Risk Analysis
Before starting the project, I identified a number of risks which are shown below (click to expand):

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Risks.jpg)

<a name="Back"></a>
## Back end architecture
My application consists of four services working together. In the first implementation, service 2 generates a random number between 0 and 2, service 3 generates a random letter between A and C and service 4 generates a proverb based on this random number and letter. This proverb is then sent to service 1 which displays it to the user. In the second implementation, the number is between 3 and 5 and a new set of proverbs is generated. Each service is deployed inside a Docker container and there is also an nginx container acting as a reverse proxy. The structure of my containers is shown below:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Containers.jpg)

The application is also connected to an SQL database which consists of two tables, Users and Proverbs. The Users table stores user information while the Proverbs table stores the proverbs generated by each user so that users can view all of their previously-generated proverbs at a later date. The structure of the tables is shown below:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/ERD.jpg)

The overall structure of the project can be seen here:

https://github.com/amoghvnaik/project2repo/blob/master/documentation/project_structure.txt

<a name="Front"></a>
## Front end architecture
Before users are logged in, the front end consists of four pages: home, about, login and register. After login, users can access the 'Generate Proverb' and 'My Proverbs' pages, modify their account details and log out. There is also a navigation bar for easy access to all of the pages. The front end design is extremely minimalistic and in the future I would look at incorporating Bootstrap to improve the design. The design of the website is shown below:

### Home page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Home.png)

### About Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/About.png)

### Register Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Register.png)

### Login Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Login.png)

### Generate Proverb Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Generate.png)

### My Proverbs Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Myproverbs.png)

### Account Page:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Account.png)

<a name="Testing"></a>
## Testing
I used pytest to test my services. The results of the tests are shown below:

### Service 1:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Service_1_test.png)

Index.html: https://github.com/amoghvnaik/project2repo/blob/master/documentation/index1.html

### Service 2:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Service_2_test.png)

Index.html: https://github.com/amoghvnaik/project2repo/blob/master/documentation/index2.html

### Service 3:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/Service_3_test.png)

Index.html: https://github.com/amoghvnaik/project2repo/blob/master/documentation/index3.html

In general, test coverage for service 1 was satisfactory considering that I only used unit testing and not integration testing. The coverage of service 2 and 3 was perfect, which is unsurprising considering that these services had a very simple function. Unfortunately, I was unable to test service 4 as testing this service would require services 2 and 3 to be running and this can only be achieved by using integration testing or similar methods. In the future, I would look at incorporating integration testing to improve the test coverage for service 1 and to make testing service 4 possible.

<a name="Deployment"></a>
## CI Pipeline & Deployment 
I deployed the application using a Continuous Integration (CI) pipeline. The basic structure is shown below:

![alt text](https://github.com/amoghvnaik/project2repo/blob/master/documentation/CI_pipeline.jpg)

The application is created and manually tested in the development VM using information from project tracking (Trello). It is then pushed to Git and the project tracking can be updated. Once the code has been pushed to Git, Jenkins is automatically triggered using a webhook. Jenkins reads the Jenkinsfile and builds and pushes the Docker images to a registry container in the Jenkins VM - automated testing is performed when building. It then connects to the Swarm VM via SSH and updates the application by using Docker Swarm. Thus, rolling updates can easily be performed. The application is then deployed to the web server via the Gunicorn WSGI. My justification for using Git is that it is highly secure, flexible and has excellent community support. My justification for using Jenkins is that it is free, highly customisable and portable to all major platforms. The environments for the Jenkins and Swarm VMs can be provisioned by using the Ansible playbook and inventory in this repository.

<a name="Guide"></a>
## User Guide to Launch Application
To launch the application on Linux, you must do the following:
* Create an SQL instance in GCP, remembering the username, password and IP
* Create two databases in the SQL instance and remember their names
* Open your terminal
* Enter the .bashrc file by using the command 'vim .bashrc'
* Add the following environment variables to your .bashrc: 
  1. 'export MYSQL_USER={your username}'
  2. 'export MYSQL_PASSWORD={your password}'
  3. 'export MYSQL_IP={your database IP}'
  4. 'export MYSQL_DB={your first database}'
  5. 'export MYSQL_DB_TEST={your second database}'
  6. 'export MYSQL_KEY={anything}'
* Install Git on your machine using the command 'sudo apt install git'
* Clone down this repository by using the command 'git clone https://github.com/amoghvnaik/project2.git'
* Enter the application folder by using the command 'cd project2'
* Run the first installation file by using the command '. ./install.sh'. This will close your terminal.
* Open your terminal again
* Enter the application folder by using the command 'cd project2'
* Run the second installation file by using the command '. ./install2.sh'
* Run the application on localhost using the command 'docker-compose up -d --build'
* Stop the application using the command 'docker-compose down'

Obviously, this is a fairly lengthy process and in the future, I would simplify it by creating an SQL container within the application rather than requiring users to create their own SQL instance.

<a name="Conclusion"></a>
## Project Changes & Conclusion
In my initial plan, I was planning to have only four Docker containers for my four services. However, in my final application I also have an nginx container acting as a reverse proxy, which makes the application more secure by making it harder to access the back end services. In the future, I would look at incorporating Bootstrap, integration testing and running the database in a Docker container rather than a separate instance.

In conclusion, I was able to successfully plan, create, test and deploy a service-oriented application, using DevOps technologies such as Github, Jenkins, Docker and Ansible to satisfy all of the SFIA project aims to the best of my ability. 

<a name="Acknowledgements"></a>
## Acknowledgements
I would like to thank the fantastic instructuctors at QA Academy for providing me with the technical skills required to complete this project.
